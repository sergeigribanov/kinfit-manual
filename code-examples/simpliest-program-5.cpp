   /* Задаем временную переменную kf_chi2 для хранения величины хи-квадрат
    и инициализируем ее бесконечным значением. */
   double kf_chi2 = std::numeric_limits<double>::infinity();
  /* Далее необходимо сделать перебор по всем "интересным" фотонам.
   Предположим, что индексы интересных фотонов из tr_ph были предварительно
   отписаны пользователем в вектор  photonIndices. Тогда перебор по всем парам фотонов
   будет выглядеть следуюшим оббразом. */
   for (int iph = 0; iph + 1 < (int) photonIndices.size(); ++iph) {
     /* Заполнение параметров и матрицы ошибок для фотона с именем "g0". 
	Если матрица ошибок необратима --- переход к следующей итерации цикла. */
     if (!hypo.fillPhoton("g0", photonIndices[iph], *this)) continue;
     for (int jph = iph + 1; jph < (int) _photonIndices.size(); ++jph) {
       // Заполнение параметров и матрицы ошибок для фотона с именем "g1"
       if (!hypo.fillPhoton("g1", photonIndices[jph], *this)) continue;
       // Вызов процедуры оптимизации.
       hypo.optimize();
